name: "Pre-Prod"

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:

env:
  APP: "skeleton-application-frontend"
  OWNER: "seanmcguigan"
  REPO: "poker-app"
  IMAGE_REPO: 907375451839.dkr.ecr.eu-west-1.amazonaws.com/futrli/skeleton-application-frontend
  AWS_REGION: "eu-west-1"

jobs:
  git_tag:
    name: Git tag master for release.
    permissions:
      contents: write
    outputs: 
      current_short_sha: ${{ steps.short_sha.outputs.short_sha }}
      previous_release_tag: ${{ steps.prod_tag.outputs.prod_tag }}
      new_release_tag: ${{ steps.calculate_prod_tag.outputs.new_prod_tag }}
      current_date: ${{ steps.date.outputs.date }}

    runs-on: ubuntu-latest
    steps:
      - name: Get current date
        id: date
        run: |
          date=$(date +%Y%m%d%H%M%S)
          echo date=$date >> $GITHUB_OUTPUT

      - name: checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: "0"

      - name: get current commit sha @main
        id: short_sha
        run: |
          short_sha=$(git rev-parse --short ${{ github.sha }})
          echo short_sha=$short_sha >> $GITHUB_OUTPUT

      - name: get previous release tag
        id: prod_tag
        run: |
          prod_tag=$(gh release view --json tagName | jq --raw-output .tagName)
          echo prod_tag=$prod_tag >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ github.token }}

      - name: increment tag version for next release
        id: calculate_prod_tag
        run: |
          new_prod_tag="${{ env.APP }}-${{ steps.short_sha.outputs.short_sha }}-${{ needs.current_date.outputs.date }}"
          echo "new_prod_tag=$new_prod_tag" >> $GITHUB_OUTPUT
      
      # always tags the latest master with the next calculated release tag
      - name: tag latest
        uses: rickstaa/action-create-tag@v1
        id: "tag_create"
        with:
          tag: ${{ steps.calculate_prod_tag.outputs.new_prod_tag }}
          force_push_tag: true
        env:
          GH_TOKEN: ${{ github.token }}

      - name: outputs
        run: | 
          echo "Output short sha ${{ steps.short_sha.outputs.short_sha }}"
          echo "Output current release tag ${{ steps.prod_tag.outputs.prod_tag }}"
          echo "Output new release tag ${{ steps.calculate_prod_tag.outputs.new_prod_tag }}"
          echo "Output build date ${{ needs.current_date.outputs.date }}"
  
  release:
    needs: git_tag
    name: Create new draft release.
    permissions:
      contents: write
    runs-on: ubuntu-latest
    steps:
      - name: outputs
        run: |
          echo "The recorded short commit sha ${{ needs.git_tag.outputs.current_short_sha }}"
          echo "The current prod release tag ${{ needs.git_tag.outputs.previous_release_tag }}"
          echo "The new prod release tag ${{ needs.git_tag.outputs.new_release_tag }}"
          echo "Output build date ${{ needs.current_date.outputs.date }}"

      - name: checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: "0"

      # Close existing draft releases
      - name: delete draft releases
        run: |
          for RELEASE_ID in $(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/$OWNER/$REPO/releases \
            | jq --raw-output '.[] | select(.draft==true) | .id')
          do 
            echo deleting draft $RELEASE_ID
            gh api \
            --method DELETE \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/$OWNER/$REPO/releases/$RELEASE_ID 
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Create draft release notes      
      - name: create draft release notes
        id: "release_content"
        run: |
          notes=$(gh api --method POST -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" \
          /repos/$OWNER/$REPO/releases/generate-notes \
          -f tag_name=${{ needs.git_tag.outputs.new_release_tag }} \
          -f target_commitish="main" \
          -f previous_tag_name=${{ needs.git_tag.outputs.previous_release_tag }} \
          -f configuration_file_path=".github/release.yml" | jq .body)
          echo -e "$notes" > /tmp/release-notes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Create a release draft      
      - name: create new draft release
        run: |
          gh api --method POST -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" \
          /repos/$OWNER/$REPO/releases \
          -f tag_name=${{ needs.git_tag.outputs.new_release_tag }} \
          -f target_commitish="main" \
          -f name="${{ needs.git_tag.outputs.new_release_tag }}" \
          -f body="$(cat /tmp/release-notes | sed -e 's/^"//' -e 's/"$//')" \
          -F draft=true \
          -F prerelease=false \
          -F generate_release_notes=false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  docker_tag:
    needs: [git_tag, release]
    name: Docker tag and push to ECR.
    runs-on: ubuntu-latest
    steps:
      - name: outputs
        run: |
          echo "The recorded short commit sha ${{ needs.git_tag.outputs.current_short_sha }}"
          echo "The current prod release tag ${{ needs.git_tag.outputs.previous_release_tag }}"
          echo "The new prod release tag ${{ needs.git_tag.outputs.new_release_tag }}"
          echo "Output build date ${{ needs.current_date.outputs.date }}"

      # Check latest staging docker image tag matches the draft github tag.
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ECR login
        uses: aws-actions/amazon-ecr-login@v1

      # Get the latest staging docker image tag and confirm it matches whats been captured in ${{ needs.git_tag.outputs.current_short_sha }}
      - name: Get the latest staging image tag and compare.
        id: "latest_staging_tag"
        run: |
          tag=$(aws ecr describe-images --output json --repository-name futrli/${{ env.APP }} \
          --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[*]' --output text | grep -Eo "staging-[a-z0-9]+-[0-9]+")

          if [[ "$tag" == *"staging-${{ needs.git_tag.outputs.current_short_sha }}"* ]]; then
            echo -e "latest image tags:\n$tag\n\nmatch git short sha:\nstaging-${{ needs.git_tag.outputs.current_short_sha }}"
            echo tag=$tag >> $GITHUB_OUTPUT
          else
            echo "tags don't match"; exit 1
          fi
          
      - name: ECR pre-prod tag
        uses: abronin/ecr-retag-action@v1
        with:
          repository: "futrli/${{ env.APP }}"
          tag: "${{ steps.latest_staging_tag.outputs.tag }}"
          new-tags: "pre-prod-${{ needs.git_tag.outputs.current_short_sha }}-${{ needs.current_date.outputs.date }}"

      # kicks off the docker tag workflow - with args
      # delete ecr user
      # sort out env vars $VAR ${{ env.VAR }}
